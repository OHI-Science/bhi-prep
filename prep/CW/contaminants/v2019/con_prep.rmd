---
title: "Clean Water (CW) - Contaminants (CON) Subgoal Data Preparation"
output:
  github_document:
    toc: true
    toc_depth: 3
params:
    datasource: csv
always_allow_html: true
---

<br>

```{r con preamble prep including spatial functions and files, message = FALSE, warning = FALSE, include = FALSE}
loc <- here::here("prep", "CW", "contaminants")

source(here::here("R", "setup.R"))
knitr::opts_chunk$set(message = FALSE, warning = FALSE, results = "hide", fig.width = 9.5)

bkgd_path <- here::here("supplement", "goal_summaries", "con_summary.Rmd")
data_path <- here::here("data", "CW", "contaminants", version_year, "con_data.rmd")
refs_path <- file.path(loc, "con_references.Rmd")

source(here::here("R", "spatial.R"))
buffer_sf <- st_read(
  file.path(dirname(dir_B), "Shapefiles", "BHI_shapefile_25km_buffer"), 
  "BHI_shapefile_25km_buffer"
)
```

<br>

## 1. Background {-}

```{r con background, child = bkgd_path, results = "asis", echo = FALSE}
```

<br/>

## 2. Data {-}

This prep document is used to generate and explore the following data layers: 

- `cw_con_pcb_bhi2019.csv` 
- `cw_con_pfos_bhi2019.csv` 
- `cw_con_dioxin_bhi2019.csv` 
- `cw_con_penalty_bhi2019.csv` 

These are saved to the `layers` folder. Intermediate datasets saved to `data/CW/contaminants/v2019/intermediate` include: `pcb_bio_cleaned.csv`, `pcb_sed_cleaned.csv`, `pfos_bio_cleaned.csv`, `dioxin_bio_cleaned.csv` and `dioxin_sed_cleaned.csv`. All these are derived from or informed by the following raw datasets.


```{r con data, child = data_path, results = "asis", echo = FALSE}
```

<br/>

## 3. Wrangling, Evaluation, and Gapfilling {-} 

```{r function to load datasets created in con_data, echo = TRUE, results = "hide", message = FALSE}
read_clean_df <- function(filename){
  read_csv(
    file.path(dirname(data_path), "intermediate", filename),
    ## ensure column types are read correctly...
    col_types = cols(
      bulk_id = col_character(),
      qflag = col_character(),
      `LIPIDWT%` = col_number(),
      `DRYWT%` = col_number(),
      `EXLIP%` = col_number(),
      WTMEA = col_number(),
      WTMIN = col_number(),
      WTMAX = col_number(),
      sub_samp_id = col_number(),
      LNMEA = col_number(), 
      LNMAX = col_number(),
      LNMIN = col_number(),
      unit = col_character()
    )
  )
}
```

<!-- **Station Impact Codes** -->

<!-- Note: as of `BHI2.0` the original station library has been replaced by a new web application -->

<!-- [Site monitoring purpose](https://vocab.ices.dk/?ref=42) `monit_purpose` vocabulary reference for codes. -->

<!-- Some sites have had the site type recorded in the ICES station dictionary ([see ICES vocabulary reference for codes](https://vocab.ices.dk/?ref=177). It is pertinent to know which sites are catagorized as:   -->

<!-- **RH** = WFD R(HZ) - Representative of general conditions in terms of hazardous substances   -->
<!-- **B** = WFD B - Baseline/Reference station   -->
<!-- **Any of the codes containing "I"** (Starting with IH or IP) which refers to a specific type of impact at the site.   -->
<!-- **RP** = WFD R(PHY) - Representative of general conditions for nutrients/organic matter  -->

<!-- It appears that only Swedish sites have this information entered. Given only Swedish sites have this information recorded, it seems difficult to use this information to include or exclude sites.   -->

<!-- From the station dictionary definitions: -->

<!-- All_Biota_Data: Data type (DTYPE) CF - all parameters - contaminants and biological effects of contaminants including disease in biota   -->
<!-- Contaminant_parameters_in_biota: Data type (DTYPE) CF - Contaminant parameter groups   -->

---

<br>

### 3.1 PCB Indicator {-}

#### 3.1.1 Match BHI Regions {-}

```{r assign BHI regions to PCB data, echo = TRUE, message = FALSE, warning = FALSE}
## use 'read_clean_df' function from above to read cleaned data with correct data types for columns
## use 'join_rgns_info' helper function defined in R/spatial.R
pcb_bio <- join_rgns_info(
  read_clean_df("pcb_bio_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
pcb_sed <- join_rgns_info(
  read_clean_df("pcb_sed_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
```

#### 3.1.2 Filter PCBs to ICES6 Set or PCB7 for Sediment {-}

The PCBs indicator uses only the ICES6 congeners: CB28, CB52, CB101, CB138, CB153, CB180. Additionally, only herring are used from the biota datasets, as they are fairly equally spatially distributed across the baltic sea, while many other species are predominantly in the south.

```{r filter pcb data}
## for the PCBs indicator we use the ICE6 congeners:
ices6_congeners <- c("CB101", "CB138", "CB153", "CB180", "CB28", "CB52")
## for PCBs in sediment we use the seven from the Norwegian Environment Agency EQS in sediment for 28 EU priority substances
## note: this sum is also included in the raw dataset as 'SCB7' but as of BHI2.0 all such observations are for the UK 
pcb7sed_congeners <- c("CB28", "CB52", "CB101", "CB118", "CB138", "CB153", "CB180")

all_pcb_bio <- pcb_bio %>% 
  filter(!is.na(value_wet_wgt)) %>% 
  filter(str_detect(species, pattern = "Clupea harengus")) %>%
  ## check that rows are distinct: nrow(pcb_bio) == nrow(distinct(pcb_bio))...
  select(
    variable, value_wet_wgt, detect_lim_wet_wgt, quant_lim_wet_wgt,
    species, num_indiv_subsample, monit_program, monit_purpose, monit_year,
    sub_samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day
  )
## keep all_pcb_bio as separate so can get dioxin-like pcbs from it later
pcb_bio <- filter(all_pcb_bio, variable %in% ices6_congeners)

all_pcb_sed <- pcb_sed %>% 
  filter(!is.na(value_dry_wgt)) %>%
  ## check that rows are distinct: nrow(pcb_sed) == nrow(distinct(pcb_sed))...
  select(
    variable, value_dry_wgt, detect_lim_dry_wgt, quant_lim_dry_wgt,
    num_indiv_subsample, monit_program, monit_purpose, monit_year,
    samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day
  ) %>% 
  filter(!is.na(BHI_ID)|!is.na(Subbasin))
## keep all_pcb_sed as separate so can get dioxin-like pcbs from it later
pcb_sed <- filter(all_pcb_sed, variable %in% pcb7sed_congeners)
```

<br> 

##### Checking Outliers/Questionable Measurements {.tabset .tabset-fade .tabset-pills} {-}

###### PCBs in Biota {-}

```{r checking pcb bio data and outliers, results = "show", fig.width = 10, fig.height = 8}
## something funky with some stations are these outliers or incorrectly recorded data??
## points in 2014 in poland highlighted in BHI1.0 as questionable, but kept in analysis...
## for some reason it is the nonflagged data that are the problem?
pcb_bio <- mutate(pcb_bio, chk = !(country == "Poland" & year == 2014 & !qflagged))
plotdf <- mutate(pcb_bio, value_adj = ifelse(qflagged, value_wet_wgt/2, value_wet_wgt)) 

makeplot <- function(data){
  ggplot(data) + 
    geom_point(aes(date, value_adj), show.legend = FALSE, size = 0.5, alpha = 0.5, color =  "grey") +
    facet_wrap(~variable, scales = "free_y", nrow = length(unique(data$variable))) +
    labs(x = NULL, y = NULL) +
    theme(plot.title = element_text(size = 8)) 
}
gridExtra::grid.arrange(
  makeplot(plotdf) + 
    geom_point(data = filter(plotdf, !chk), aes(date, value_adj), shape = 1) +
    ggtitle("All Data"),
  makeplot(filter(plotdf, chk)) + 
    ggtitle("W/O Poland year 2014"),
  ncol = 2
)
# pcb_bio <- filter(pcb_bio, chk) %>% select(-starts_with("chk"))
```

***
<br>

###### PCBs in Sediment {-}

```{r checking pcb sed data and outliers, results = "show", fig.width = 10, fig.height = 8}
## only a few samples yielding all high concentration values
# distinct(filter(pcb_sed, value_dry_wgt > 60), country, year, month, station, samp_ref)
# distinct(filter(pcb_sed, value_dry_wgt > 120), country, year, month, station, samp_ref)
pcb_sed <- pcb_sed %>% 
  mutate(
    # chk = !(station == "FYN 3" & samp_ref == 293730),
    chk = !(samp_ref %in% c(293793, 293730, 308450, 308411, 2224866))
  )
plotdf <- mutate(pcb_sed, value_adj = ifelse(qflagged, value_dry_wgt/2, value_dry_wgt))

gridExtra::grid.arrange(
  makeplot(plotdf) +
    geom_point(data = filter(plotdf, !chk), aes(date, value_adj), shape = 1) +
    ggtitle("All Data"),
  makeplot(filter(plotdf, chk)) + 
    ggtitle("W/O station FYN 3 sample #293730 Oct2000"),
  ncol = 2
)
# pcb_sed <- filter(pcb_sed, chk) %>% select(-starts_with("chk"))
```

***
<br>

##### Visualize flagged data in Timeseries {-}

Below the data are plotted in congener-subbasin combinations. Colorscale corresponds to number of observations, with lighter blues/greens indicating more observations for the given date-congener-subbasin group, while darker colors indicate fewer observations in the dataset for the given date-congener-subbasin combination.

```{r pcbs bio qflag adjustment congeners by basin, fig.show = "hide", fig.height = 19.5, fig.width = 9.5}
## pcb qflag adjustment congeners by basin and congener, 
## red x's indicate flagged data, colorscale indicates number of observations
qflag_timeseries_plot <- function(data, valvarname, plottitle){
  
  plotdf <- data %>% 
    mutate(value_adj = ifelse(qflagged, !!sym(valvarname)/2, !!sym(valvarname))) %>% 
    mutate(value_adj_original = ifelse(qflagged, !!sym(valvarname), NA)) %>% 
    group_by(date, variable, Subbasin) %>% 
    mutate(countObs = n(), meanAdjww = mean(value_adj, na.rm = TRUE)) %>% 
    ungroup()
  
  ggplot(plotdf) + 
    scale_color_distiller(palette = "GnBu", direction = -1) +
    geom_point(aes(date, value_adj, color = countObs), show.legend = FALSE, size = 0.9, alpha = 0.4) +
    geom_point(aes(date, value_adj_original), color = "red", shape = 4, size = 1.2, alpha = 0.7) +
    facet_wrap(
      c("variable", "Subbasin"), 
      labeller = label_wrap_gen(width = 35, multi_line = FALSE), 
      scales = "free_y", 
      ncol = 4
    ) +
    labs(x = NULL, y = NULL, title = plottitle) +
    theme_bw()
}

qflag_timeseries_plot(
  pcb_bio, "value_wet_wgt", 
  "Congener Concentration (ug/kg wet weight) measured in Clupea harengus\n"
)
```

```{r pcbs sed qflag adjustment congeners by basin, fig.show = "hide", fig.height = 30, fig.width = 9.5}
qflag_timeseries_plot(
  pcb_sed, "value_dry_wgt", 
  "Congener Concentration (ug/kg dry weight) measured in Sediments\n"
)
```

***
<br>

#### 3.1.3 Evaluate Flagged Data, Station Impact, & Sampling Patterns {-}

<br>

**What do the `qflags` indicate? Quantification limits, Flags Codes**

- **<** = less than  

- **>** = greather than  

- **D** = reported value is less than the detection limit (detect_lim)  

- **Q** = reported value is less than the limit of quantification (quant_lim)  

- **~** separates multiple flags  


```{r what do the qflags indicate, results = "show", fig.width = 9.5, fig.height = 3}
## what do the qflags actually indicate?
chk_pcb_bio_qflags <- pcb_bio %>% 
  select_at(vars(matches("qflag|value|quant|detect"))) %>% 
  filter(qflagged) %>% 
  mutate(qflag = str_split(qflag, "~")) %>% 
  tidyr::unnest(qflag) %>%
  mutate(
    ## from guess-check-plot, it appears the following is mostly correct, with minimal inconsistencies...
    ## < and Q flags indicates less than or equal to quantification limit, 
    ## D flag indicates less than detection limit
    chk = case_when(
      qflag == "D" ~ value_wet_wgt < detect_lim_wet_wgt,
      qflag == "Q" ~ value_wet_wgt <= quant_lim_wet_wgt,
      qflag == "<" ~ value_wet_wgt <= quant_lim_wet_wgt
    )
  )
## from guess-check-plot, it appears the following is mostly correct, with minimal inconsistencies...
## < and Q flags indicates less than or equal to quantification limit, 
## D flag indicates less than detection limit
ggplot(chk_pcb_bio_qflags) +
  geom_bar(aes(chk, fill = chk), position = position_dodge()) +
  scale_fill_manual(values = c("firebrick", "paleturquoise3"), na.value = "whitesmoke") +
  facet_wrap(~qflag, nrow = 1, scales = "free") +
  labs(
    x = "\nConc. value â‰¤ Quantification Limit ('<' and 'Q'), Conc. value < Detection Limit ('D')", 
    y = NULL, 
    fill = NULL
  )  +
  theme_dark()
```

---

<br>

##### Congener-Sums Timeseries by Country {.tabset .tabset-fade .tabset-pills} {-}

**Defining two approaches to deal with flagged data**

The function below aggregates the data spreading by variable (so each congner has a column and each date/location/sample is a single row) and summing the congeners rowwise to get date/location/sample specific concentration sums of the specified congners. The function allows for two approaches to handling flagged data: "NoQflag" which removes the flagged observations or "Adjusted" which adjust values. Adjustment of values would ideally use detect_lim/2, however since detect_lim values are not always provided, we apply the transformation to the reported data value.

```{r function to adjust qflagged data}
qflag_adjust <- function(dataset, indicator, congeners = NULL, matrix = "bio", sumcongeners = TRUE, approach = "Adjusted"){
  
  ## Two alternative approaches for summarizing the data:
  ## Adjusted: sum the adjusted values, for the 6 ICES congeners
  ## NoQflag: sum only observation with no qflagged values
  if(approach == "NoQflag"){
    dataset <- filter(dataset, !qflagged)
  }
  
  if(indicator != "dioxin"){
    if(matrix == "bio"){
      dataset <- dataset %>% 
        rename(value_plot = value_wet_wgt) %>% 
        select(-detect_lim_wet_wgt, -quant_lim_wet_wgt)
    } else {
      dataset <- dataset %>% 
        rename(value_plot = value_dry_wgt) %>% 
        select(-detect_lim_dry_wgt, -quant_lim_dry_wgt)
    }
  } else {
    dataset <- dataset %>% 
      rename(value_plot = value_teq) %>% 
      select(-ends_with("_lim_wet_wgt"))
  }
  
  ## aggregate into single date-location values:
  ## sum concentration after flagged data adjustment and date-location averages per congener
  data_Qadjust_sums <- dataset %>% 
    ## adjust for qflags
    ## NOTE if all qflagged are removed, all adjusted values equal original values
    mutate(value_adj = ifelse(qflagged, value_plot/2, value_plot)) %>% 
    ## after dealing with flagged values, may have duplicates; take mean of these 
    select(-qflag, -qflagged, -value_plot) %>% 
    tidyr::pivot_wider(
      names_from = variable, 
      values_from = value_adj,
      values_fn = list(value_adj = mean)
    )
  
  if(indicator == "dioxin"){
    data_Qadjust_sums <- data_Qadjust_sums %>% 
      mutate(sum_congeners = select(., congeners) %>% rowSums(na.rm = TRUE)) %>% 
      mutate(num_congener_in_sum = rowSums(!is.na(select(., congeners))))
  } else {
    ## sum congeners by date and location
    ## remove cases where not all congeners are observed by filtering NAs
    if(sumcongeners & !is.null(congeners)){
      data_Qadjust_sums <- data_Qadjust_sums %>% 
        mutate(sum_congeners = select(., congeners) %>% rowSums()) %>% 
        filter(!is.na(sum_congeners))
    }
  }
  return(data_Qadjust_sums)
}

pcb_bio_qflag_adjust <- qflag_adjust(pcb_bio, "pcb", congeners = ices6_congeners)
pcb_sed_qflag_adjust <- qflag_adjust(pcb_sed, "pcb", congeners = pcb7sed_congeners, matrix = "sed")

pcb_bio_noqflag <- qflag_adjust(pcb_bio, "pcb", congeners = ices6_congeners, approach = "NoQflag")
pcb_sed_noqflag <- qflag_adjust(pcb_sed, "pcb", congeners = pcb7sed_congeners, matrix = "sed", approach = "NoQflag")
```

<!-- To visualize by country or basin pass "country" or "subbasin" respectively to `cntry_or_basin` arguement  -->
```{r function for congeners timeseries monthly by basin, echo = TRUE}
## timeseries plots, congeners by country
plot_cwcon_initial <- function(dataset, col_pal, contam_param = "OC-CB", matrix = "bio", cntry_or_basin = "subbasin"){
  
  ## one of OC-CB, OC-DX or O-FL; becomes OC, DX, or FL respectively
  contam_param <- substr(contam_param, str_length(contam_param)-1, str_length(contam_param))
  if(contam_param == "FL"){contam_param <- "PF"}
  if(contam_param == "DX"){contam_param <- "CD"}
  cntry_or_basin <- str_to_lower(cntry_or_basin)
  
  dat <- dataset %>% 
    rename(subbasin = Subbasin) %>% 
    select(month, Year = year, zone = cntry_or_basin, contains(contam_param)) %>% 
    filter(!is.na(zone), Year > 2000) %>% 
    tidyr::pivot_longer(
      cols = starts_with(contam_param), 
      names_to = "Congener", 
      values_to = "value_plot"
    ) %>%  
    group_by(Congener, month, Year, zone) %>%
    summarize(Value = mean(value_plot, na.rm = TRUE) %>% round(3)) %>%
    ungroup() %>%
    mutate(Date = as.Date(paste("1", month, Year, sep = "-"), tryFormats = "%d-%m-%Y"))
  
  ## reorder factor levels of congeners so colors will match across plots for same congeners
  if(contam_param == "CB"){
    if(isTRUE(all.equal(names(select(dataset, starts_with(contam_param))), ices6_congeners))){
      dat$Congener <- factor(dat$Congener, levels = ices6_congeners)
    }
    if(isTRUE(all.equal(names(select(dataset, starts_with(contam_param))), pcb7sed_congeners))){
      dat$Congener <- factor(dat$Congener, levels = c(ices6_congeners, "CB118"))
    }
    dioxinlike_pcbs <- c("CB118","CB156","CB105","CB169","CB167","CB77","CB157")
    if(isTRUE(all.equal(names(select(dataset, starts_with(contam_param))), dioxinlike_pcbs))){
      dat$Congener <- factor(dat$Congener, levels = dioxinlike_pcbs)
    }
  }
  if(contam_param == "CD"){
    sed_dioxins <- c(
      "CDD1N","CDD4X","CDD6P","CDD6X","CDD9X","CDDO","CDF2N","CDF2T",
      "CDF4X","CDF6P","CDF6X","CDF9P","CDF9X","CDFO","TCDD"
    )
    if(matrix == "sed"){
      dat$Congener <- factor(dat$Congener, levels = sed_dioxins)
    } else {dat$Congener <- factor(dat$Congener, levels = c(sed_dioxins, "CDFDN"))}
  }
  
  
  ## timeseries plots of all congeners by country
  plot <- ggplot(data = dat, aes(Date, Value, fill = Congener)) +
    geom_col(position = "stack", show.legend = FALSE) +
    scale_x_date(
      breaks = function(x){seq.Date(from = min(dat$Date), to = max(dat$Date), by = "3 months")},
      date_labels = "%b %Y"
    ) +
    scale_fill_manual(values = col_pal) +
    labs(x = NULL, y = NULL) +
    theme(axis.text.x = element_text(angle = 45, size = 6)) +
    facet_wrap(~zone, scales = "free_y", ncol = 1)
  
  return(plot) # return(plotly::ggplotly(plot))
}
```

<br>

**Visualize Timeseries, Monthly Sums**

###### PCB Congeners in Biota {-}

```{r congeners timeseries monthly by basin for biota, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 6}
## create color palettes
fullpal <- c(
  RColorBrewer::brewer.pal(8, "Dark2"),
  RColorBrewer::brewer.pal(9, "Set1")
)
cols <- colorRampPalette(fullpal)(42)[sample(1:42, size = 6)]
plot_cwcon_initial(pcb_bio_qflag_adjust, col_pal = cols, contam_param = "OC-CB", cntry_or_basin = "country")
# plotly::ggplotly(plot_cwcon_initial(pcb_bio_qflag_adjust, col_pal = cols, contam_param = "OC-CB", cntry_or_basin = "country"))
```

***
<br>

###### PCB Congeners in Sediments {-}

```{r congeners timeseries monthly by basin for sediments, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 6}
plot_cwcon_initial(pcb_sed_qflag_adjust, c(cols, "turquoise"), "OC-CB", "sed", "country")
```

***
<br>

##### Spatial distributions of PCB sampling Locations {-}

```{r function for mapping spatial dist of data points}
if(!exists("bhi_rgns_simple")|!"sf" %in% class(bhi_rgns_simple)){
  bhi_rgns_simple <- rmapshaper::ms_simplify(
  input =  sf::st_read(
    dsn = file.path(dirname(dir_B), "Shapefiles", "BHI_shapefile_corrected"), 
    layer = "BHI_shapefile_corrected",
    quiet = TRUE
  )) %>% sf::st_as_sf()
}

map_cwcon_initial <- function(dataset, yr, obs_count_limits, matrix = NULL){
  
  if(!"Matrix" %in% names(dataset)){
    dataset <- dataset %>% 
      mutate(Matrix = matrix)
  } else {
    dataset <- dataset %>% 
      mutate(Matrix = ifelse(
        str_detect(Matrix, "bio"), "biota",
        ifelse(str_detect(Matrix, "sed"), "sediment", NA))
      )
    if(nrow(filter(dataset, is.na(Matrix))) > 0){
      message("missing matrix value (bio or sed) in some rows")
    }
  }
  
  df <- left_join(
    bhi_rgns_simple %>% 
      # select(BHI_ID) %>% 
      # mutate(BHI_ID = as.character(BHI_ID)),
      select(HELCOM_ID) %>% 
      mutate(HELCOM_ID = as.character(HELCOM_ID)),
    dataset %>% 
      filter(year %in% yr) %>% 
      # group_by(BHI_ID, Matrix) %>% 
      group_by(Subbasin, HELCOM_ID, Matrix) %>% 
      summarise(
        meanVal = mean(sum_congeners_datemean, na.rm = TRUE),
        matrix_ObservCount = n(),
        numLocation = n_distinct(latitude, longitude)
      ) %>% 
      # group_by(BHI_ID) %>% 
      group_by(Subbasin, HELCOM_ID) %>% 
      mutate(ObservCount = sum(matrix_ObservCount)),
    # by = "BHI_ID"
    by = "HELCOM_ID"
  )
  
  map <- ggplot(df) + 
    geom_sf(aes(fill = ObservCount), color = "burlywood", size = 0.2, alpha = 0.95) +
    scale_fill_gradient(
      low = "midnightblue", 
      high = "lightcyan", 
      na.value = "whitesmoke", 
      limits = obs_count_limits,
      breaks = round(seq(0,6)*max(obs_count_limits)/6, 1)
    ) +
    geom_sf(
      data = st_as_sf(dataset, coords = c("longitude", "latitude"), crs = 4326) %>% filter(year %in% yr), 
      mapping = aes(color = Matrix, shape = Matrix),
      size = 3
    ) +
    scale_color_manual(values = c("limegreen", "brown1")) +
    scale_shape_manual(values = c(13, 13)) +
    theme_linedraw() +
    theme(legend.position = c(0.1, 0.78), legend.background = element_rect(color = "grey")) +
    guides(fill = guide_legend(order = 2))
  
  df <- df %>% 
    st_drop_geometry() %>% 
    filter(!is.na(Matrix)) %>% 
    distinct() %>% 
    right_join(
      tidyr::expand_grid(
        Subbasin = as.character(unique(bhi_rgns_simple$Subbasin)), 
        Matrix = c("biota", "sediment")
      ), 
      by = c("Subbasin", "Matrix")
    )
  
  if(length(unique(dataset$Matrix)) == 1){df <- filter(df, Matrix == "biota")}
  
  basinplot <- ggplot(df) +
    geom_point(
      aes(Subbasin, meanVal, fill = matrix_ObservCount, size = numLocation),
      color = "burlywood", shape =  21
    ) +
    labs(x = NULL, y = "Mean concentration (ug/kg)\n", color = NULL) +
    scale_fill_gradient(
      low = "midnightblue", 
      high = "lightcyan", 
      na.value = "whitesmoke", 
      limits = obs_count_limits
    ) +
    facet_grid(rows = vars(Matrix), scales = "free") +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1), 
      legend.position = c(0.87, 0.82),
      legend.background = element_rect(color = "grey", fill = NA),
      strip.text.y = element_text(size = 8, angle = 0)
    ) +
    guides(fill = FALSE)
  
  return(list(map = map, basinplot = basinplot))
}

## bind resulting dataset to plot together and evaluate....
pcb_qflag_adjust_datemeans <- bind_rows(
  pcb_bio_qflag_adjust %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(Matrix = "bio"),
  pcb_sed_qflag_adjust %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(Matrix = "sed")
) %>% ungroup()

pcb_noqflag_datemeans <- bind_rows(
  pcb_bio_noqflag %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(Matrix = "bio"),
  pcb_sed_noqflag %>% 
    group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
    summarize(sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE)) %>% 
    mutate(Matrix = "sed")
) %>% ungroup()
```

```{r map spatial dist of PCBs multiple years, results = "show", fig.width = 13, fig.height = 7.5, out.width = "120%"}
pcb2014to2019 <- map_cwcon_initial(pcb_qflag_adjust_datemeans, yr = 2014:2018,  c(0, 15), matrix = "both")
gridExtra::grid.arrange(pcb2014to2019$map, pcb2014to2019$basinplot, nrow = 1, widths = c(1.2, 1))
```

***
<br>

#### 3.1.4 Status and Trend Options {-}

**Most-recent Years in Data Layers for each Approach to Flagged Data**

```{r pcbs latest years for qflag adjust vs no flagged data approaches, results = "show"}
htmlTable::htmlTable(
  full_join(
    pcb_qflag_adjust_datemeans %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_Adjusted = last(year)) %>% 
      filter(!is.na(Subbasin)),
    pcb_noqflag_datemeans %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_NoQflag = last(year)) %>% 
      filter(!is.na(Subbasin)),
    by = "Subbasin"
  ) %>% select(lastyr_Adjusted, lastyr_NoQflag, Subbasin),
  align = "rcl", 
  rnames = FALSE,
  css.cell = c(
    rep("padding-left: 5em; padding-right: 2em", 2),
    "padding-left: 14em; padding-right: 9em"
  ),
  col.rgroup = c("none", "#F7F7F7")
)
```

***
<br>

**A function to calculate the Indicators**

The function below takes as inputs: datalayer, years across which data is to be aggregated in status calculation, the biota reference point for the contaminant (health threshold in same units as datalayer values) and the sediment reference point, the trend-calculation approach, and trend lag i.e. the number of years we want to project into the future. Default approach for calculating the trend (scaledObs) is to scale the observations by the matrix-and-contaminant-specific reference point, capping at one, then group by spatial unit (BHI region or Subbasin) and matrix, and regress the scaled values against year; the year coefficient multiplied by `trendlag` becomes the trend score. Other approaches considered are: calculating trend with zscores of data, or using a mixed-effects model to try to account for different stations. See commented code below for more details.

```{r calculations of cw con indicators status and trend}
cwcon_indicators <- function(dat, yrs, bio_thresh = 75, sed_thresh = 4.1, approach = "relativeChange", trendlag = 5){
  
  result <- list()
  
  joindf <- bhi_rgns_simple %>% 
    st_drop_geometry() %>% 
    select(-Area_km2) %>% 
    mutate(
      Subbasin = as.character(Subbasin), 
      HELCOM_ID = as.character(HELCOM_ID),
      rgn_nam = as.character(rgn_nam), 
      rgn_key = as.character(rgn_key)
    )
  
  ## STATUS CALCULATIONS ----
  ## calculate status by subbasins and by bhi regions
  
  result[["basin_status"]] <- dat %>%
    filter(year %in% yrs) %>% 
    ## NOTE: CHANGE METHOD FROM BHI1.0
    ## compare to reference point and cap at one before averaging concentrations,
    ## effectively giving more weight to the few higher-concentration values
    mutate(
      health_threshold = ifelse(str_detect(Matrix, "^bio"), bio_thresh, sed_thresh),
      ratio = sum_congeners_datemean/health_threshold,
      ## using pmin to cap the status at one
      dateloc_status = pmin(1, 1/ratio)
    ) %>%
    group_by(HELCOM_ID, Subbasin, Matrix) %>% 
    summarize(
      ## number of date-location specific (aggregated) data points contributing to status
      ## plus some other summary statisics of interest
      num_dateloc_pts = n(),
      status = mean(dateloc_status, na.rm = TRUE),
      max_dateloc_pts = max(sum_congeners_datemean, na.rm = TRUE),
      min_dateloc_pts = min(sum_congeners_datemean, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    group_by(HELCOM_ID, Subbasin) %>% 
    summarize(status = mean(status, na.rm = TRUE)) %>% # status from biota & sediment data combined w equal wgt
    right_join(joindf, by = c("Subbasin", "HELCOM_ID"))
  
  result[["bhirgn_status"]] <- dat %>%
    filter(year %in% yrs) %>% 
    mutate(
      health_threshold = ifelse(str_detect(Matrix, "^bio"), bio_thresh, sed_thresh),
      ratio = sum_congeners_datemean/health_threshold,
      ## using pmin to cap the status at one
      dateloc_status = pmin(1, 1/ratio)
    ) %>%
    group_by(BHI_ID, Matrix) %>% 
    summarize(
      ## number of date-location specific (aggregated) data points contributing to status
      ## plus some other summary statisics of interest
      num_dateloc_pts = n(),
      status = mean(dateloc_status, na.rm = TRUE),
      max_dateloc_pts = max(sum_congeners_datemean, na.rm = TRUE),
      min_dateloc_pts = min(sum_congeners_datemean, na.rm = TRUE)
    ) %>%
    ungroup() %>%
    group_by(BHI_ID) %>% 
    summarize(status = mean(status, na.rm = TRUE)) %>%
    right_join(joindf, by = c("BHI_ID"))


  ## TREND CALCULATIONS ----
  ## calculate trend by subbasins and by bhi regions; use method specified in function args
  ## three approaches to calculating trend: mixed-effects, linear model
  for(zn in c("basin", "bhirgn")){
    
    ## ten years used in contaminants trend calculations
    trendyrs <- (max(yrs)-9):max(yrs)
    
    if(zn == "basin"){
      grpvars <- c("HELCOM_ID", "Subbasin")
      lstname <- "basin_trend"
    } else {
      grpvars <- c("BHI_ID")
      lstname <- "bhirgn_trend"
    }
    
    if(approach == "relativeChange"){
      ## trend approach 1: by observations scaled w.r.t. to reference point
      lm_dat <- dat %>% 
        filter(year %in% trendyrs) %>% 
        group_by(!!!syms(grpvars), Matrix) %>% 
        mutate(
          trendcalc_nyrs = n_distinct(year),
          num_obs = n()
        ) %>% 
        ## how much data is enough data to calculate short-term trends?
        filter(trendcalc_nyrs >= 6|(trendcalc_nyrs >= 4 & num_obs > 8))
      
      lm_estim <- lm_dat %>% 
        do(trend_mdl = lm(sum_congeners_datemean ~ year, data = .)) %>%
        mutate(
          health_threshold = ifelse(Matrix == "bio", bio_thresh, sed_thresh),
          ## change w.r.t. health thresholds...
          expectedchange5yrs = coef(trend_mdl)["year"]*trendlag,
          trendscore = -expectedchange5yrs/health_threshold,
          ## plotting variables, to visualize
          current_estimated_conc = predict(trend_mdl, data.frame(year = max(yrs))),
          projected_conc = predict(trend_mdl, data.frame(year = max(yrs)+trendlag))
        ) %>% 
        ungroup()
      ## plot to check...
      # ggplot(left_join(lm_dat, select(lm_estim, Subbasin, current_estimated_conc, projected_conc))) +
      #   geom_point(aes(x = year, y = sum_congeners_datemean, color = Matrix)) +
      #   geom_vline(xintercept = max(yrs)) +
      #   geom_vline(xintercept = max(yrs)+trendlag) +
      #   geom_hline(aes(yintercept = projected_conc, color = Matrix), alpha = 0.3) +
      #   geom_hline(aes(yintercept = current_estimated_conc, color = Matrix)) +
      #   facet_wrap(~Subbasin, scales = "free") +
      #   labs(x = "Year", y = "Congeners Concentration")
      
      result[[lstname]] <- lm_estim %>% 
        select(-trend_mdl) %>% 
        group_by(!!!syms(grpvars)) %>% 
        summarize(trend = mean(trendscore, na.rm = TRUE) %>% round(3)) %>%
        ## constrain trend values between one and negative one
        mutate(trend = ifelse(-1 <= trend & trend <= 1, trend, trend*abs(1/trend))) %>% 
        right_join(joindf, by = grpvars)
    }
    
    ## trend approach 2: calculate trend with zscores of data
    if(approach == "zscores"){
      dat_zscore <- dat %>% 
        filter(year %in% trendyrs) %>% 
        group_by(!!!syms(grpvars), Matrix) %>% 
        mutate(
          trendcalc_nyrs = n_distinct(year),
          mn = mean(sum_congeners_datemean),
          sd = sd(sum_congeners_datemean),
          zscore = (sum_congeners_datemean-mn)/sd
        )
      if(any(dat_zscore$trendcalc_nyrs < 5)){
        message("some trends calculated with fewer than five years")
      }
      if(any(is.na(dat_zscore$zscore))){
        message(sprintf(
          "zscore NAs (%s cases) caused trends calculation to fail", 
          nrow(filter(datalayer_zscore, is.na(zscore)))
        ))
      }
      result[[lstname]] <- dat_zscore %>% 
        filter(!is.na(zscore)) %>% 
        group_by(!!!syms(grpvars), Matrix) %>% 
        do(trend_mdl = lm(zscore ~ year, data = .)) %>% 
        mutate(trend = coef(trend_mdl)["year"]*trendlag) %>% 
        ungroup() %>% 
        select(-trend_mdl) %>% 
        group_by(!!!syms(grpvars)) %>% 
        summarize(trend = mean(trend, na.rm = TRUE)) %>% 
        right_join(joindf, by = grpvars)
    }
    
    ## trend approach 3: mixed effects
    ## current error: not enough observations per group...
    ## number of levels of each grouping factor must be < number of observations 
    ## would use the following piece of code to fit model.....
    # do({
    #   if(distinct(., latitude) %>% nrow() > 1){
    #     (trend_mdl = lme4::lmer(zscore ~ year + (1|latitude), data = .))
    #   } else {(trend_mdl = lm(zscore ~ year, data = .))}
    # }) %>% 
  }
  
  return(result)
}
```

**Compare two approaches to deal with flagged data, for BHI regions vs Basin**

1. Start with mean ICES6 conc. by date and location (unique observations)
2. Scale observations compared to the relevant contaminant-and-matrix-relevant reference point, capping at one
3. Calculate status as mean of all scaled obs. for past 5 years in either BHI region or basin 
4. Compare by-basin and by-BHI region results for status and for trend, assess number of data points contributing 

```{r investigate approaches to qflags and summarizing by region vs basin pcb indicator, fig.width = 9.5, fig.height = 8}
## using function defined above, investigate:
## (1) adjusting vs excluding flagged data, and 
## (2) aggregating data by subbasin versus BHI regions in calculating status and trend
pcb_qflag_adjust_indicators <- cwcon_indicators(pcb_qflag_adjust_datemeans, yrs = 2014:2018)
pcb_noqflag_indicators <- cwcon_indicators(pcb_noqflag_datemeans, yrs = 2014:2018)
## to try with biota data only...
# pcb_qflag_adjust_indicators <- cwcon_indicators(pcb_qflag_adjust_datemeans %>% filter(Matrix == "bio"), yrs = 2015:2019)
# pcb_noqflag_indicators <- cwcon_indicators(pcb_noqflag_datemeans %>% filter(Matrix == "bio"), yrs = 2015:2019)

pcb_status <- bind_rows(
  pcb_qflag_adjust_indicators$basin_status %>% 
    mutate(approach = "Adjusted", spatialunits = "Subbasins"),
  pcb_qflag_adjust_indicators$bhirgn_status %>% 
    mutate(approach = "Adjusted", spatialunits = "BHI Regions"),
  pcb_noqflag_indicators$basin_status %>% 
    mutate(approach = "NoQflag", spatialunits = "Subbasins"),
  pcb_noqflag_indicators$bhirgn_status %>% 
    mutate(approach = "NoQflag", spatialunits = "BHI Regions")
)
pcb_status <- pcb_status %>%
  mutate(Region = paste(Subbasin, rgn_nam, sep = ", ")) %>% 
  mutate(approach_sp_unit = paste(spatialunits, approach))
pcb_status$spatialunits <- factor(pcb_status$spatialunits, levels = c("Subbasins", "BHI Regions"))

statuspal <- colorRampPalette(fullpal)(42)[sample(1:42, size = 18)]

ggplot(pcb_status, aes(Region, status, fill = Subbasin)) +
  geom_col(position = position_dodge(), color = "grey", alpha = 0.7, show.legend = FALSE) + 
  scale_fill_manual(values = statuspal) +
  facet_grid(rows = vars(approach), cols = vars(spatialunits)) +
  coord_flip() +
  labs(x = NULL, y = NULL) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 7))
```

<br>

#### 3.1.5 Save PCB contaminants layer and intermediate datasets {-}

```{r save pcbs contaminants layer and any intermediate datasets, eval = FALSE}
write_csv(
  pcb_qflag_adjust_datemeans %>% 
    select(
      region_id = BHI_ID,
      latitude, longitude, 
      year,
      value = sum_congeners_datemean, 
      matrix = Matrix
    ), 
  file.path(dir_layers, sprintf("cw_con_pcb_bhi%s.csv", assess_year))
)
```

<br>

#### 3.1.6 Methods discussion {-}

Only herring (no other species) used from biota dataset, because herring are most equally spatially spaced across the baltic sea, whereas others are mostly in the south.

**Status formula, ICES6 PCBs Biota and 7PCBs in Sediment**

$X_{\mbox{ICES6}} = \min\{\mbox{bio_reference_point/mean_ICES6_region, } 1\}$

$X_{\mbox{7sedPCB}} = \min\{\mbox{sed_reference_point/mean_7sedPCB_region, } 1\}$

$X_{\mbox{PCB}} = (X_{\mbox{ICES6}} + X_{\mbox{7sedPCB}})/2$

$\mbox{bio_reference_point} = \mbox{health_threshold} = 75ug/kg\mbox{ wet weight}$

$\mbox{sed_reference_point} = \mbox{health_threshold} = 4.1ug/kg\mbox{ dry weight}$


Score scaled between 0 and 1. If value is below 75, score = 1.

<br>

**Conclusions & Decisions regarding Status and Trend Options**

- Including the qflag-adjusted values lowers the mean concentration by date and location
- Including qflag-adjusted values also provides more observations in the Kattegat, The Quark, and W. Gotland Basin
- When aggregating by BHI regions, more observations for Regions 1, 11, 26, 35, 36, 39, 41, 42 when including qflagged values
- Using data including qflag-adjusted (this could lower values), 

- Use 5 year mean ICES6 concentration for status
- Use the five status years plus another five prior for the regression that factors into trend calculation

<br>

**Trend Considerations**

- Work on mixed effect model for trends?  
- Need to think about the interpretation of the data treatment. (a) If use raw observations, then normalize (zscore data), then fit trend, if get increase or decrease but all values are below the threshold, does it make sense to apply a change in the trend to the status?  Would we really think the future status will be lower?  (b) If take all raw observations, calculate "status" as done for the mean value, then fit trend, is this more true to the idea that variation below the human health threshold should not affect the trajectory of the future status?  
- Need to think if simple linear regression is okay, or if need to account for site?  

<br>

**`BHI1.0` discussions with Anna Sobek **

- Indicator choice: We agreed that *ICES6 is the best* option  
- Decision about use of qflagg-adjusted data: *use qflagged data with the adjustement* of (congener conc/2)  
- Decision about spatial scale of the data: decide best approach is to *calculate for each basin*  
- Trend decision: best approach is first convert individual observations to a "status" relative to the human health threshold, then fit linear model by basin for **10 year period**. (Tred Check: Does the trend value need to be rescaled to between -1 and 1? Does not exceed now but need to consider if method broadly works?)  

<!-- **`BHI2.0` discussions with Anna Sobek ** -->

***

<br>

### 3.2 PFOS Indicator {-}

#### 3.2.1 Match BHI Regions {-}

**Use Lat/Long to Match BHI Regions**

```{r assign BHI regions to PFOS data, echo = TRUE, message = FALSE, warning = FALSE}
# use 'join_rgns_info' helper function defined in spatial.R
pfos <- join_rgns_info(
  read_clean_df("pfos_bio_cleaned.csv"),
  helcomID_col = "HELCOM_ID",
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
```

#### 3.2.2 Filter Organofluorines Data keeping only PFOS in Clupea harengus {-}

Only herring (Clupea harengus) are used from the biota datasets, as they are fairly equally spatially distributed across the baltic sea, while many other species are predominantly in the south. Also, heerring are . In the raw organofluorine dataset, matrix analyzed for most measurements was liver but there were some also where muscle was analyzed. In the initial data cleaning (see `bhi-prep/data/CW/contaminants/v2019/con_data.rmd`), the concentrations from liver measurements were converted to muscle equivalent using the report: [Distribution of PFAS in liver and muscle of herring, perch, cod, eelpout, arctic char, and pike from limnic and marine environments in Sweden. Faxneld et al 2014](https://www.diva-portal.org/smash/get/diva2:767385/FULLTEXT01.pdf).

```{r subset pfos data}
pfos <- pfos %>% 
  filter(!is.na(value_pfos_muscle_equiv_wet_wgt)) %>% 
  filter(str_detect(species, pattern = "Clupea harengus")) %>%
  filter(variable == "PFOS") %>% 
  select(
    species, num_indiv_subsample, monit_program, monit_purpose, monit_year,
    sub_samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day,
    variable, 
    ## rename variables so functions defined earlier in the script can be applied
    value_wet_wgt = value_pfos_muscle_equiv_wet_wgt, 
    detect_lim_wet_wgt = detect_lim_pfos_muscle_equiv_wet_wgt, 
    quant_lim_wet_wgt = quant_lim_pfos_muscle_equiv_wet_wgt
  )
```


#### 3.2.3 Evaluate Flagged Data & Sampling Patterns {-}

##### Visualize PFOS flagged data in Timeseries {-}

PFOS data plotted by subbasin. Colorscale in plot one corresponds to number of observations, with lighter blues/greens indicating more observations for the given date-congener-subbasin group, while darker colors indicate fewer observations in the dataset for the given date-congener-subbasin combination. Plot 2 shows the same information in boxplot format, with data grouped by year. 

###### Concentrations Timeseries and Boxplots with Observation Counts {-}

```{r pfos qflag adjustment values by basin, fig.show = "hide", fig.width  = 9.5, fig.height = 8}
## pcb qflag adjustment congeners by basin and congener, 
## red x's indicate flagged data, colorscale indicates number of observations
plotdf <- pfos %>% 
  mutate(value_adj = ifelse(qflagged, value_wet_wgt/2, value_wet_wgt)) %>% 
  mutate(value_adj_original = ifelse(qflagged, value_wet_wgt, NA)) %>% 
  group_by(date, variable, Subbasin) %>% 
  mutate(countObs = n(), meanAdjww = mean(value_adj, na.rm = TRUE)) %>% 
  ungroup()

ggplot(plotdf) + 
  scale_color_distiller(palette = "GnBu", direction = -1, limits = c(0, 15)) +
  geom_point(aes(date, value_adj, color = countObs), show.legend = FALSE, size = 1.5, alpha = 0.8) +
  ## no flagged values that needed adjustment as of BHI2.0
  # geom_point(aes(date, value_adj_original), color = "red", shape = 4, size = 1, alpha = 0.6) +
  facet_wrap(~ Subbasin, scales = "free_y", ncol = 3) +
  labs(x = NULL, y = "Congener Concentration (ug/kg wet weight, muscle equivalent) measured in Clupea harengus") +
  theme_bw()
```

```{r pfos qflag adjusted values basin boxplots, fig.show = "hide", fig.width  = 9.5, fig.height = 8}
boxplotdf <- plotdf %>%
  mutate(year = as.factor(year)) %>% 
  group_by(year, variable, Subbasin) %>% 
  mutate(countObs = sum(countObs)) %>% 
  select(year, date, variable, Subbasin, meanAdjww, countObs) %>% 
  distinct()

ggplot(boxplotdf) + 
  scale_color_distiller(palette = "GnBu", direction = -1, limits = c(0, 155)) +
  scale_fill_distiller(palette = "GnBu", direction = -1, limits = c(0, 155)) +
  geom_boxplot(
    aes(year, meanAdjww, color = countObs, fill = countObs), 
    show.legend = FALSE, 
    alpha = 0.7, 
    outlier.size = 0.4
  ) + 
  facet_wrap(~ Subbasin, ncol = 3) +
  scale_x_discrete(breaks = c(2005, 2010, 2015)) +
  labs(
    x = NULL, 
    y = "Congener Daily Mean Concentrations (ug/kg wet weight muscle equivalent) measured in Clupea harengus"
  ) +
  theme_bw()
```

***
<br>

##### Spatial distributions of PFOS sampling Locations, Years 2014-2018 {-}

```{r pfos map of data records, results = "show", fig.width = 13, fig.height = 7.5, out.width = "120%"}
pfos_qflag_adjust <- qflag_adjust(pfos, indicator = "pfos", sumcongeners = FALSE)
pfos_qflag_adjust_datemeans <- pfos_qflag_adjust %>% 
  group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
  summarize(sum_congeners_datemean = mean(PFOS, na.rm = TRUE)) %>%
  mutate(Matrix = "bio") %>% 
  ungroup()

pfos_noqflag <- qflag_adjust(pfos, indicator = "pfos", sumcongeners = FALSE, approach = "NoQflag")
pfos_noqflag_datemeans <- pfos_noqflag %>% 
  group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
  summarize(sum_congeners_datemean = mean(PFOS, na.rm = TRUE)) %>% 
  mutate(Matrix = "bio") %>% 
  ungroup()

pfos2008to2019 <- map_cwcon_initial(pfos_qflag_adjust_datemeans, yr = 2014:2018, c(0, 15))
gridExtra::grid.arrange(pfos2008to2019$map, pfos2008to2019$basinplot, nrow = 1, widths = c(1.2, 1))
```

***
<br>

#### 3.2.4 Status and Trend Options {-}

**Most-recent Years in Data Layers for each Approach to Flagged Data**

```{r pfos latest years for qflag adjust vs no flagged data approaches, results = "show"}
htmlTable::htmlTable(
  full_join(
    pfos_qflag_adjust_datemeans %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_Adjusted = last(year)) %>% 
      filter(!is.na(Subbasin)),
    pfos_noqflag_datemeans %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_NoQflag = last(year)) %>% 
      filter(!is.na(Subbasin)),
    by = "Subbasin"
  ) %>% select(lastyr_Adjusted, lastyr_NoQflag, Subbasin),
  align = "rcl", 
  rnames = FALSE,
  css.cell = c(
    rep("padding-left: 5em; padding-right: 2em", 2),
    "padding-left: 14em; padding-right: 9em"
  ),
  col.rgroup = c("none", "#F7F7F7")
)
```

***
<br>

**Compare two approaches to deal with flagged data, for BHI regions vs Basin**

1. Start with mean concentrations by date and location 
2. Scale observations compared to the relevant contaminant-and-matrix-relevant reference point, capping at one
3. Calculate status as mean of all scaled obs. for past 5 years in either BHI region or basin 
4. Compare by-basin and by-BHI region results for status and for trend, assess number of data points contributing 

```{r investigate approaches to qflags and summarizing by region vs basin pfos indicator, fig.width = 9.5, fig.height = 8}
## using function defined above, investigate:
## (1) adjusting vs excluding flagged data, and 
## (2) aggregating data by subbasin versus BHI regions in calculating status and trend
pfos_qflag_adjust_indicators <- cwcon_indicators(pfos_qflag_adjust_datemeans, yrs = 2014:2018, bio_thresh = 9.1)
pfos_noqflag_indicators <- cwcon_indicators(pfos_noqflag_datemeans, yrs = 2014:2018, bio_thresh = 9.1)

pfos_status <- bind_rows(
  pfos_qflag_adjust_indicators$basin_status %>% 
    mutate(approach = "Adjusted", spatialunits = "Subbasins"),
  pfos_qflag_adjust_indicators$bhirgn_status %>% 
    mutate(approach = "Adjusted", spatialunits = "BHI Regions"),
  pfos_noqflag_indicators$basin_status %>% 
    mutate(approach = "NoQflag", spatialunits = "Subbasins"),
  pfos_noqflag_indicators$bhirgn_status %>% 
    mutate(approach = "NoQflag", spatialunits = "BHI Regions")
)
pfos_status <- pfos_status %>%
  mutate(Region = paste(Subbasin, rgn_nam, sep = ", ")) %>% 
  mutate(approach_sp_unit = paste(spatialunits, approach))

pfos_status$spatialunits <- factor(pfos_status$spatialunits, levels = c("Subbasins", "BHI Regions"))

ggplot(pfos_status, aes(Region, status, fill = Subbasin)) +
  geom_col(position = position_dodge(), color = "grey", alpha = 0.7, show.legend = FALSE) + 
  scale_fill_manual(values = statuspal) +
  facet_grid(rows = vars(approach), cols = vars(spatialunits)) +
  coord_flip() +
  labs(x = NULL, y = NULL) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 7))
```

<br>

#### 3.1.5 Save PFOS contaminants layer and intermediate datasets {-}

```{r save pfos contaminants layer and any intermediate datasets, eval = FALSE}
write_csv(
  pfos_qflag_adjust_datemeans %>% 
    select(
      region_id = BHI_ID,
      latitude, longitude, 
      year,
      value = sum_congeners_datemean, 
      matrix = Matrix
    ), 
  file.path(dir_layers, sprintf("cw_con_pfos_bhi%s.csv", assess_year))
)
```

<br>

---

#### 3.1.6 Methods discussion {-}

**Status formula, ICES6 PCBs Biota and 7PCBs in Sediment**

**Conclusions & Decisions regarding Status and Trend Options**

**Trend Considerations**

---

<br>

### 3.3 Dioxin Indicator {-}
#### 3.3.1 Match BHI Regions {-}

Dioxins and dioxin-like PCBs datasets are manipulated as separate objects for the next steps, combined only in the last code chunk before section 3.3.3 'Status and Trend Options'. Sediment and biota datasets for each dioxins and dioxin-like PCBs are joined before spatial plotting.

```{r assign BHI regions to Dioxin data, echo = TRUE, message = FALSE, warning = FALSE}
## use 'join_rgns_info' helper function defined in spatial.R
dioxin_bio <- join_rgns_info(
  read_clean_df("dioxin_bio_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
dioxin_sed <- join_rgns_info(
  read_clean_df("dioxin_sed_cleaned.csv"),
  latlon_vars = c("latitude", "longitude"),
  rgn_shps_loc = file.path(dirname(dir_B), "Shapefiles"),
  return_spatial = FALSE,
  buffer_shp = buffer_sf
)
```

<br>

#### 3.3.2 Filter Dioxin-like PCBs to join with Dioxins dataset, and Convert all to Toxic Equivalents {-}

To convert dioxin and dioxin-like PCB congener concentrations to toxic equivalents we use the [IPCS Reference Table](https://www.who.int/ipcs/assessment/tef_values.pdf), taken from The 2005 World Health Organization Re-evaluation of Human and Mammalian Toxic Equivalency Factors for Dioxins and Dioxin-like Compounds (Van den Berg et al, 2005).

```{r TEQ conversion lookup, fig.show = "hide"}
tef_pdf <- pdftools::pdf_text("https://www.who.int/ipcs/assessment/tef_values.pdf")[1] %>%
  stringr::str_split(pattern = "\n")
tef_lookup <- as.data.frame(tef_pdf[[1]][2:34])
colnames(tef_lookup) <- "singlecolumn"
tidyr::separate(tef_lookup, singlecolumn, c("WHO_compound_name", "TEF_1998", "TEF_2005"), "\\s\\s+")

## manually matched with ICES congeners names...
## congeners in the tablee without a TEF value are not dioxin-like
lookup_tef <- read_csv(here::here("supplement", "lookup_tabs", "tef_conversion_lookup.csv"))
```

**Filter PCB to keep only dioxin-like PCBs, convert units, and convert to TEQ**

```{r filter dioxin like PCBs and convert units ug to pg per gram}
## get dioxin-like PCBs by joining TEF lookup table
## filter out congeners without a TEF conversion
## convert from micrograms/kilogram to picograms/gram and calculate TEQs
## ug/kg equivalent to 1000 pg/g
dioxinlike_pcbbio_teq <- all_pcb_bio %>%
  inner_join(lookup_tef, by = c("variable" = "congener")) %>%
  filter(!is.na(TEF_2005)) %>%
  mutate(value_teq = 1000*value_wet_wgt*TEF_2005) %>% 
  select(-congener_full, -WHO_compound_name, -congener_category, -TEF_2005) %>% 
  select(-ends_with("wet_wgt"))

dioxinlike_pcbsed_teq <- all_pcb_sed %>%
  inner_join(lookup_tef, by = c("variable" = "congener")) %>%
  filter(!is.na(TEF_2005)) %>%
  mutate(value_teq = 1000*value_dry_wgt*TEF_2005) %>% 
  select(-congener_full, -WHO_compound_name, -congener_category, -TEF_2005) %>% 
  select(-ends_with("dry_wgt"))
```

**Use TEF conversion factor to convert Dioxin concentrations to TEQ**

```{r subset dioxin data and convert to TEQ}
## subset dioxin datasets
dioxin_bio <- dioxin_bio %>%
  filter(!is.na(value_wet_wgt)) %>% 
  filter(str_detect(species, pattern = "Clupea harengus")) %>%
  ## check that rows are distinct: nrow(dioxin_bio) == nrow(distinct(dioxin_bio))...
  select(
    variable, value_wet_wgt, detect_lim_wet_wgt, quant_lim_wet_wgt,
    species, num_indiv_subsample, monit_program, monit_purpose, monit_year,
    sub_samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day
  ) 
dioxin_sed <- dioxin_sed %>%
  filter(!is.na(value_dry_wgt)) %>%
  ## check that rows are distinct: nrow(dioxin_sed) == nrow(distinct(dioxin_sed))...
  select(
    variable, value_dry_wgt, detect_lim_dry_wgt, quant_lim_dry_wgt,
    num_indiv_subsample, monit_program, monit_purpose, monit_year,
    samp_ref,
    qflagged, qflag, 
    country, Subbasin, HELCOM_ID, BHI_ID, latitude, longitude, station,
    date, year, month, day
  ) %>% 
  filter(!is.na(BHI_ID)|!is.na(Subbasin))

## filter out congeners without a TEF conversion
## convert from micrograms/kilogram to picograms/gram and calculate TEQs
dioxinbio_teq <- dioxin_bio %>%
  inner_join(lookup_tef, by = c("variable" = "congener")) %>%
  filter(!is.na(TEF_2005)) %>%
  mutate(value_teq = 1000*value_wet_wgt*TEF_2005) %>% 
  select(-congener_full, -WHO_compound_name, -congener_category, -TEF_2005) %>% 
  select(-ends_with("wet_wgt"))

dioxinsed_teq <- dioxin_sed %>%
  inner_join(lookup_tef, by = c("variable" = "congener")) %>%
  filter(!is.na(TEF_2005)) %>%
  mutate(value_teq = 1000*value_dry_wgt*TEF_2005) %>% 
  select(-congener_full, -WHO_compound_name, -congener_category, -TEF_2005) %>% 
  select(-ends_with("dry_wgt"))
```

##### Checking Outliers/Questionable Measurements {.tabset .tabset-fade .tabset-pills} {-}

###### Dioxin-like PCBs in Biota {-}

```{r checking dioxinlike pcb bio data and outliers, results = "show", fig.width = 10, fig.height = 8}
## something funky with some stations are these outliers or incorrectly recorded data??
dioxinlike_pcbbio_teq <- dioxinlike_pcbbio_teq %>% 
  mutate(
    ## points in 2014 in poland highlighted in BHI1.0 as questionable...
    ## for some reason it is the nonflagged data that are the problem?
    chk0 = (country == "Poland" & year == 2014 & !qflagged),
    ## additional points to investigate...
    chk1 = (station == "473" & year == 2015 & month == 7),
    chk2 = (station %in% c("SJB1454000", "SJB1455000", "SJB1453000") & year == 2018 & month == 10),
    chk3 = (station == "SJB1453000" & year == 2017 & month == 10),
    chk = !chk0&!chk1&!chk2&!chk3
  )
plotdf <- mutate(dioxinlike_pcbbio_teq, value_adj = ifelse(qflagged, value_teq/2, value_teq)) 

gridExtra::grid.arrange(
  makeplot(plotdf) + 
    geom_point(data = filter(plotdf, !chk), aes(date, value_adj), shape = 1) +
    ggtitle("All Data"),
  makeplot(filter(plotdf, !chk1)) + 
    geom_point(data = filter(plotdf, !chk1&!chk), aes(date, value_adj), shape = 1) +
    ggtitle("W/O station 473 July2015"),
  makeplot(filter(plotdf, !chk1&!chk2)) + 
    geom_point(data = filter(plotdf, !chk1&!chk2&!chk), aes(date, value_adj), shape = 1) +
    ggtitle("W/O SJB1454000/5000/3000, Oct2018"),
  makeplot(filter(plotdf, chk)) +
    ggtitle("All questionable points removed"),
  ncol = 4
)
dioxinlike_pcbbio_teq <- filter(dioxinlike_pcbbio_teq, chk) %>% select(-starts_with("chk"))
```

***
<br>

###### Dioxin-like PCBs in Sediment {-}

```{r checking dioxinlike pcb sed data and outliers, results = "show", fig.width = 10, fig.height = 8}
dioxinlike_pcbsed_teq <- dioxinlike_pcbsed_teq %>% 
  mutate(
    chk0 = (station == "FYN 3" & samp_ref == 293730),
    chk1 = (country == "Estonia" & qflag == "<" & variable %in% c("CB157", "CB167", "CB169")),
    chk = !chk0&!chk1
  )
plotdf <- dioxinlike_pcbsed_teq %>% 
  mutate(value_adj = ifelse(qflagged, value_teq/2, value_teq), country = as.factor(country))
plotdf$country <- factor(plotdf$country, levels = unique(plotdf$country)) # estonia last for matching palettes!

gridExtra::grid.arrange(
  makeplot(plotdf) +
    geom_point(aes(date, value_adj, color = country), alpha = 0.5, size = 0.5, show.legend = FALSE) +
    scale_color_manual(values = c(rep("grey", 7), "coral")) +
    geom_point(data = filter(plotdf, !chk), aes(date, value_adj), shape = 1) +
    ggtitle("All Data"),
  makeplot(filter(plotdf, !chk0)) + 
    geom_point(data = filter(plotdf, !chk0&!chk), aes(date, value_adj), shape = 1) +
    geom_point(aes(date, value_adj, color = country), alpha = 0.5, size = 0.5, show.legend = FALSE) +
    scale_color_manual(values = c(rep("grey", 7), "coral")) +
    ggtitle("W/O station FYN 3 sample #293730 Oct2000"),
  makeplot(filter(plotdf, chk)) + 
    ggtitle("All questionable points removed"),
  ncol = 3
)
dioxinlike_pcbsed_teq <- filter(dioxinlike_pcbsed_teq,chk) %>% select(-starts_with("chk"))
```

***
<br>

###### Dioxins in Biota {-}

```{r checking dioxin biota data and outliers, results = "show", fig.width = 10, fig.height = 18}
dioxinbio_teq <- dioxinbio_teq %>% 
  mutate(
    chk0 = (station == "473" & year == 2015 & month == 7),
    chk1 = (station %in% c("SJB1454000", "SJB1455000", "SJB1453000") & year == 2018 & month == 10),
    chk = !chk0&!chk1
    # chk2 = (station == "UtlÃ¤ngan" & year == 2014 & month == 6),
    # chk = !chk0&!chk1&!chk2
  )
plotdf <- mutate(dioxinbio_teq, value_adj = ifelse(qflagged, value_teq/2, value_teq)) 

gridExtra::grid.arrange(
  makeplot(plotdf) + 
    geom_point(data = filter(plotdf, !chk), aes(date, value_adj), shape = 1) +
    ggtitle("All Data"),
  makeplot(filter(plotdf, !chk0)) + 
    geom_point(data = filter(plotdf, !chk0&!chk), aes(date, value_adj), shape = 1) +
    ggtitle("W/O station 473 July2015"),
  makeplot(filter(plotdf, !chk0&!chk1)) + 
    geom_point(data = filter(plotdf, !chk0&!chk1&!chk), aes(date, value_adj), shape = 1) +
    ggtitle("W/O SJB1454000/5000/3000, Oct2018"),
  makeplot(filter(plotdf, chk)) +
    ggtitle("All questionable points removed"),
  ncol = 4
)
dioxinbio_teq <- filter(dioxinbio_teq, chk) %>% select(-starts_with("chk"))
```

---
<br>

```{r checking dioxin sediment data and outliers, fig.show = "hide", fig.width = 10, fig.height = 5.7}
dioxinsed_teq <- dioxinsed_teq %>% 
  mutate(
    chk0 = (station == "NORS-AlsMole" & year == 2007 & month == 12),
    chk1 = (station == "STO0501059" & year == 2007 & month == 11),
    chk2 = (station == "NORS-Blaakilde" & year == 2014 & month == 12),
    chk = !chk0&!chk1&!chk2
  )
plotdf <- mutate(dioxinsed_teq, value_adj = ifelse(qflagged, value_teq/2, value_teq)) 
## no apparent patterns in outliers to raise concern here
makeplot(plotdf) +
  facet_wrap(~variable, scales = "free_y", nrow = 5) +
  geom_point(data = filter(plotdf, !chk), aes(date, value_adj), shape = 1)
```


##### Visualize flagged data in Timeseries {-}

Dioxin and dioxin-like data plotted in congener-subbasin combinations. Colorscale corresponds to number of observations, with lighter blues/greens indicating more observations for the given date-congener-subbasin group, while darker colors indicate fewer observations in the dataset for the given date-congener-subbasin combination.

```{r dioxinlike pcb bio qflag adjustment congeners by basin, fig.show = "hide", fig.width = 9.5, fig.height = 18}
qflag_timeseries_plot(
  dioxinlike_pcbbio_teq, "value_teq", 
  "Congener Concentration (ug/kg TEQ wet weight) in Clupea Harengus\n"
)
```

```{r dioxinlike pcb sed qflag adjustment congeners by basin, fig.show = "hide", fig.width = 9.5, fig.height = 20.7}
qflag_timeseries_plot(
  dioxinlike_pcbsed_teq, "value_teq", 
  "Congener Concentration (ug/kg TEQ dry weight) in Sediments\n"
)
```

```{r dioxin bio qflag adjustment congeners by basin, fig.show = "hide", fig.width = 9.5, fig.height = 38.7}
qflag_timeseries_plot(
  dioxinbio_teq, "value_teq", 
  "Congener Concentration (ug/kg TEQ wet weight) in Clupea Harengus\n"
)
```

```{r dioxin sed qflag adjustment congeners by basin, fig.show = "hide", fig.width = 9.5, fig.height = 45.9}
qflag_timeseries_plot(
  dioxinsed_teq, "value_teq", 
  "Congener Concentration (ug/kg TEQ dry weight) in Sediments\n"
)
```

***
<br>

#### 3.3.3 Evaluate Flagged Data & Sampling Patterns {-}

**Adjust Qflagged values**

Use $LOD/2$ approach to adjust values. Because we do not have the LOD in all cases, use: $adjustedValue = value / 2$

<br>

**TEQ concentrations per Sample**

1. Sum TEQ concentration values for each `sub_samp_ref` in dioxin and dioxin-like PCBs in biota separately, and count number of congeners included in that sum
2. Sum TEQ concentration values for each `samp_ref` in dioxin and dioxin-like PCB in sediment separately, and count number of congeners included in that sum
3. Mean TEQ values by date and location, for each of the four datasets: dioxin-like pcbs in biota and sediments, and dioxins in biota and sediments. For observations averaged, track the mean/min/max number of congeners in each of the observations, and count the number of observations for each date and location grouping.

```{r adjust qflagged data for dioxin and dioxinlike pcbs teq data}
lapply(
  list(
    ## dioxin-like PCBs in biota, two approaches to handling qflags
    list(df = "dioxinlike_pcbbio_teq", mat = "bio", apr = "Adjusted"),
    list(df = "dioxinlike_pcbbio_teq", mat = "bio", apr = "NoQflag"),
    ## dioxin-like PCBs in sediment, two approaches to handling qflags
    list(df = "dioxinlike_pcbsed_teq", mat = "sed", apr = "Adjusted"),
    list(df = "dioxinlike_pcbsed_teq", mat = "sed", apr = "NoQflag"),
    ## Dioxins in biota, two approaches to handling qflags
    list(df = "dioxinbio_teq", mat = "bio", apr = "Adjusted"),
    list(df = "dioxinbio_teq", mat = "bio", apr = "NoQflag"),
    ## Dioxins in sediment, two approaches to handling qflags
    list(df = "dioxinsed_teq", mat = "sed", apr = "Adjusted"),
    list(df = "dioxinsed_teq", mat = "sed", apr = "NoQflag")
  ),
  function(x){
    congeners <- unique(get(x$df)$variable)
    result <- qflag_adjust(get(x$df), indicator = "dioxin", congeners, matrix = x$mat, approach = x$apr)
    assign(
      str_replace(x$df, "teq", ifelse(x$apr == "Adjusted", "qflag_adjust", "noqflag")), 
      result, 
      envir = .GlobalEnv
    )
  }
)
```

<br>

<!-- To visualize by country or basin pass "country" or "subbasin" respectively to `cntry_or_basin` arguement  -->

##### Congener (Monthly Sums) Timeseries by Country {.tabset .tabset-fade .tabset-pills} {-}

###### Dioxin-like PCBs in Biota {-}

```{r dioxinlike pcb congeners timeseries monthly by basin for biota, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 6}
cols <- colorRampPalette(fullpal)(42)[sample(1:42, size = 7)]
plot_cwcon_initial(dioxinlike_pcbbio_qflag_adjust, col_pal = cols, contam_param = "OC-CB", cntry_or_basin = "country")
```

***
<br>

###### Dioxin-like PCBs in Sediments {-}

```{r dioxinlike pcb congeners timeseries monthly by basin for sediments, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 6}
plot_cwcon_initial(dioxinlike_pcbsed_qflag_adjust, cols, "OC-CB", "sed", "country")
```

***
<br>

###### Dioxins in Biota {-}

```{r dioxin congeners timeseries monthly by basin for biota, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 6}
cols <- colorRampPalette(fullpal)(42)[sample(1:42, size = 16)]
plot_cwcon_initial(dioxinbio_qflag_adjust, col_pal = cols, contam_param = "OC-DX", cntry_or_basin = "country")
```

***
<br>

###### Dioxins in Sediments {-}

```{r dioxin congeners timeseries monthly by basin for sediments, results = "show", echo = TRUE, fig.width = 9.5, fig.height = 6}
plot_cwcon_initial(dioxinsed_qflag_adjust, col_pal = cols[-16], contam_param = "OC-DX", cntry_or_basin = "country")
```

***
<br>

**Get mean TEQs by Date and Location for Plotting**

Calculate the sum of the mean dioxin and the mean dioxin-like PCB TEQ value for each date and location. For observations averaged, also calculate mean, min, and max number of congeners in each of the observations, and also numbers of observations for each date and location.

```{r mapping spatial distribution of dioxin and dioxinlike pcbs data}
lapply(
  list(
    list("dioxinlike_pcbbio_qflag_adjust", "dioxinlike_pcbsed_qflag_adjust"),
    list("dioxinlike_pcbbio_noqflag", "dioxinlike_pcbsed_noqflag"),
    list("dioxinbio_qflag_adjust", "dioxinsed_qflag_adjust"),
    list("dioxinbio_noqflag", "dioxinsed_noqflag")
  ),
  function(x){
    datemeandf <- bind_rows(
      get(x[[1]]) %>% 
        group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
        summarize(
          sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE),
          mean_congener_in_sum = mean(num_congener_in_sum, na.rm = TRUE),
          min_congener_in_sum = min(num_congener_in_sum, na.rm = TRUE),
          max_congener_in_sum = max(num_congener_in_sum, na.rm = TRUE)
        ) %>% 
        mutate(Matrix = "bio"),
      get(x[[2]]) %>% 
        group_by(date, day, month, year, latitude, longitude, country, Subbasin, HELCOM_ID, BHI_ID) %>% 
        summarize(
          sum_congeners_datemean = mean(sum_congeners, na.rm = TRUE),
          mean_congener_in_sum = mean(num_congener_in_sum, na.rm = TRUE),
          min_congener_in_sum = min(num_congener_in_sum, na.rm = TRUE),
          max_congener_in_sum = max(num_congener_in_sum, na.rm = TRUE)
        ) %>% 
        mutate(Matrix = "sed")
    ) %>% ungroup()
    
    dfname <- paste(str_remove(x[[1]], "bio"), "datemeans", sep = "_")
    assign(dfname, datemeandf, envir = .GlobalEnv)
  }
)
```

<br>

##### Spatial distributions of Dioxin and Dioxin-like PCBs sampling Locations {.tabset .tabset-fade .tabset-pills} {-}

###### Dioxin-like PCBs years 2014-2018 {-}

```{r map spatial dist of dioxinlike pcbs, results = "show", fig.width = 13, fig.height = 7.5, out.width = "120%"}
mapdioxinlikepcb <- map_cwcon_initial(dioxinlike_pcb_qflag_adjust_datemeans, yr = 2014:2018, c(0, 30), matrix = "both")
gridExtra::grid.arrange(
  mapdioxinlikepcb$map + labs(y = "Mean concentration (pg/g)\n"), 
  mapdioxinlikepcb$basinplot, 
  nrow = 1, 
  widths = c(1.2, 1)
)
```

***
<br>

###### Dioxins years 2014-2018 {-}

```{r map spatial dist of dioxins, results = "show", fig.width = 13, fig.height = 7.5, out.width = "120%"}
mapdioxins <- map_cwcon_initial(dioxin_qflag_adjust_datemeans, yr = 2014:2018, c(0, 30), matrix = "both")
gridExtra::grid.arrange(
  mapdioxins$map + labs(y = "Mean concentration (pg/g)\n"), 
  mapdioxins$basinplot, 
  nrow = 1, 
  widths = c(1.2, 1)
)
```

***
<br>

**Assess if Dioxins and dioxin-like PCBs data overlap**

Were dioxins and PCBs measured from the same samples such that a total TEQ value per sample can be calculated?

1. Join dioxins and dioxin-like PCBs by `sub_samp_ref` or `samp_ref`, `date`, `latitude`, `longitude`
2. Get TEQ concentration for each sample reference
3. Take mean to get single TEQ value per date-location

```{r assess dioxin pcb overlaps}
## biota data

## check unique and matching sub_sample_ref
## any cases where sub_samp_ref appears in dioxin and pcb datasets? yes...
length(intersect(
  unique(dioxinlike_pcbbio_teq$sub_samp_ref), 
  unique(dioxinbio_teq$sub_samp_ref)
))

## check any shared location and sample dates?
full_join(
  dioxinlike_pcbbio_teq %>%
    select(country, station, date)%>%
    distinct() %>%
    mutate(dioxin = TRUE),
  dioxinbio_teq %>%
    select(country, station, date)%>%
    distinct() %>%
    mutate(pcb = TRUE),
  by = c("country", "station", "date")
) %>% filter(dioxin & pcb)

## sediment data

## check unique and matching sub_sample_ref
## any cases where sub_samp_ref appears in dioxin and pcb datasets? yes...
length(intersect(
  unique(dioxinlike_pcbsed_teq$samp_ref), 
  unique(dioxinsed_teq$samp_ref)
))

## check any shared location and sample dates?
full_join(
  dioxinlike_pcbsed_teq %>%
    select(country, station, date)%>%
    distinct() %>%
    mutate(dioxin = TRUE),
  dioxinsed_teq %>%
    select(country, station, date)%>%
    distinct() %>%
    mutate(pcb = TRUE),
  by = c("country", "station", "date")
) %>% filter(dioxin & pcb)
```

<br>

**Join dioxin and dioxin-like PCB observations**

Join dioxin and dioxin-like PCB observations by shared date and location. Use `inner_join` to retain only observations where both dioxin and dioxin-like PCBs were measured.

```{r sum dioxin and dioxinlike pcb mean teq values by date and location and plot, results = "show", fig.width = 9.5}
dioxins_qflag_adjust_teqs_total <- inner_join(
  dioxinlike_pcb_qflag_adjust_datemeans %>% 
    rename(
      sum_congeners_datemean_pcb = sum_congeners_datemean, 
      mean_congener_in_sum_pcb = mean_congener_in_sum,
      min_congener_in_sum_pcb = min_congener_in_sum,
      max_congener_in_sum_pcb = max_congener_in_sum
    ), 
  dioxin_qflag_adjust_datemeans %>% 
    rename(
      sum_congeners_datemean_dioxin = sum_congeners_datemean, 
      mean_congener_in_sum_dioxin = mean_congener_in_sum,
      min_congener_in_sum_dioxin = min_congener_in_sum,
      max_congener_in_sum_dioxin = max_congener_in_sum
    )
) %>% mutate(total_teq = sum_congeners_datemean_pcb + sum_congeners_datemean_dioxin)

dioxins_noqflag_teqs_total <- inner_join(
  dioxinlike_pcb_noqflag_datemeans %>% 
    rename(
      sum_congeners_datemean_pcb = sum_congeners_datemean, 
      mean_congener_in_sum_pcb = mean_congener_in_sum,
      min_congener_in_sum_pcb = min_congener_in_sum,
      max_congener_in_sum_pcb = max_congener_in_sum
    ), 
  dioxin_noqflag_datemeans %>% 
    rename(
      sum_congeners_datemean_dioxin = sum_congeners_datemean, 
      mean_congener_in_sum_dioxin = mean_congener_in_sum,
      min_congener_in_sum_dioxin = min_congener_in_sum,
      max_congener_in_sum_dioxin = max_congener_in_sum
    )
) %>% mutate(total_teq = sum_congeners_datemean_pcb + sum_congeners_datemean_dioxin)
```

---

<br>

#### 3.3.4 Status and Trend Options {-}

```{r dioxins latest years for qflag adjust vs no flagged data approaches, results = "show"}
htmlTable::htmlTable(
  full_join(
    dioxins_qflag_adjust_teqs_total %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_Adjusted = last(year)),
    dioxins_noqflag_teqs_total %>%
      arrange(year) %>%
      group_by(Subbasin) %>%
      summarise(lastyr_NoQflag = last(year)),
    by = "Subbasin"
  ) %>% filter(!is.na(Subbasin)),
  align = "lcc", 
  rnames = FALSE,
  css.cell = c(
    rep("padding-left: 5.75em; padding-right: 1.5em", 2),
    "padding-left: 10em; padding-right: 1.5em"
  ),
  col.rgroup = c("none", "#F7F7F7")
)
```

<br>

**Compare two approaches to deal with flagged data, for BHI regions vs Basin**

1. Start with total TEQs: congeners summed per sample, means by date and location, dioxin and dioxin-like PCB summes added together per unique date and location  
2. Take mean of all unique obs. for latest 5 years in either BHI region or basin
3. Compare by-basin and by-BHI region results for status and for trend, assess number of data points contributing

```{r investigate approaches to qflags and summarizing by region vs basin dioxin indicator, fig.width = 9.5, fig.height = 8}
## using function defined above, investigate:
## (1) adjusting vs excluding flagged data, and 
## (2) aggregating data by subbasin versus BHI regions in calculating status and trend
dioxin_qflag_adjust_indicators <- cwcon_indicators(
  dioxins_qflag_adjust_teqs_total %>% rename(sum_congeners_datemean = total_teq), 
  bio_thresh = 6.5, sed_thresh = 0.86, 
  yrs = 2014:2018
)
dioxin_noqflag_indicators <- cwcon_indicators(
  dioxins_noqflag_teqs_total %>% rename(sum_congeners_datemean = total_teq), 
  bio_thresh = 6.5, sed_thresh = 0.86, 
  yrs = 2014:2018
)
dioxin_status <- bind_rows(
  dioxin_qflag_adjust_indicators$basin_status %>% 
    mutate(approach = "Adjusted", spatialunits = "Subbasins"),
  dioxin_qflag_adjust_indicators$bhirgn_status %>% 
    mutate(approach = "Adjusted", spatialunits = "BHI Regions"),
  dioxin_noqflag_indicators$basin_status %>% 
    mutate(approach = "NoQflag", spatialunits = "Subbasins"),
  dioxin_noqflag_indicators$bhirgn_status %>% 
    mutate(approach = "NoQflag", spatialunits = "BHI Regions")
)
dioxin_status <- dioxin_status %>%
  mutate(Region = paste(Subbasin, rgn_nam, sep = ", ")) %>% 
  mutate(approach_sp_unit = paste(spatialunits, approach))

dioxin_status$spatialunits <- factor(dioxin_status$spatialunits, levels = c("Subbasins", "BHI Regions"))

ggplot(dioxin_status, aes(Region, status, fill = Subbasin)) +
  geom_col(position = position_dodge(), color = "grey", alpha = 0.7, show.legend = FALSE) + 
  scale_fill_manual(values = statuspal) +
  facet_grid(rows = vars(approach), cols = vars(spatialunits)) +
  coord_flip() +
  labs(x = NULL, y = NULL) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 7))
```

<br>

#### 3.3.5 Save Dioxin contaminants layer and intermediate datasets {-}

```{r save dioxin contaminants layer and any intermediate datasets, eval = FALSE}
write_csv(
  dioxins_qflag_adjust_teqs_total %>% 
    select(
      region_id = BHI_ID,
      latitude, longitude, 
      year,
      value = total_teq, 
      matrix = Matrix
    ), 
  file.path(dir_layers, sprintf("cw_con_dioxin_bhi%s.csv", assess_year))
)
```

<br>

---

#### 3.3.6 Methods discussion {-}

**Status formula**

$X_{dioxinTEQ} = \min\{1, \mbox{ teq threshold}/\mbox{mean dioxin-like pcb teq value}\}$

**Conclusions & Decisions regarding Status and Trend Options**

**Trend Considerations**

---

### 3.4 Concerning Substances Indicator {-}

This indicator is a new addition since the `BHI1.0`, conceptualized as a more comprehensive way to account for the fact that many concerning, hazardous substances are not currently monitored in the Baltic Sea. In the earlier assessment, a penalty factor of 0.1 was applied to the entire Baltic to reduce the contaminant subgoal scores so they better reflected this concerning situation. This method uses [a list compiled by ECHA of concerning substances](https://echa.europa.eu/candidate-list-table?p_p_id=disslists_WAR_disslistsportlet&p_p_lifecycle=1&p_p_state=normal&p_p_mode=view&p_p_col_id=column-1&p_p_col_pos=2&p_p_col_count=3&_disslists_WAR_disslistsportlet_javax.portlet.action=searchDissLists), and involves cross-referencing with those monitored substances in the [ICES contaminants databases for biota](http://dome.ices.dk/views/ContaminantsBiota.aspx) [and for sediments](http://dome.ices.dk/views/ContaminantsSediment.aspx). Those on the list which are monitored, are assessed for spatial coverage of monitoring; substances on the list may be monitored somewheree in the Baltic Sea, but only in some basins or for some countries. The final indicator score is the percentage of substances on the list that are monitored in the given region. 

```{r function to evaluate spatial coverage of monitored}
get_spatial_monitor_info <- function(substance_data_filepath, matrix = "bio", bhi_join_tab){
  
  if(matrix == "bio"){
    df <- readr::read_delim(substance_data_filepath, delim = ";")
  }  
  if(matrix == "sed"){
      df <- readr::read_delim(substance_data_filepath, delim = ";") %>% 
        filter(DEPHL <= 0.05)
  }
  countdf <- df %>%
    dplyr::select(
      country = Country, station = STATN, 
      year = MYEAR, ices_date = DATE, 
      lat = Latitude, lon = Longitude,
      param_group = PARGROUP, variable = PARAM, 
      measurement_ref = tblParamID,
      samp_ref = tblSampleID,
      sub_samp_id = SUBNO, bulk_id = BULKID,
      sub_samp_ref = matches("tblBioID"),
      press_depth = matches("DEPHU"), depth_low = matches("DEPHL")
    ) %>% 
    # filter(year %in% yrs) %>% 
    join_rgns_info(buffer_shp = buffer_sf) %>% 
    mutate(country = ifelse(
      !is.na(rgn_nam) & country != rgn_nam, 
      as.character(rgn_nam), 
      country
    )) %>% 
    filter(!is.na(BHI_ID)) %>% 
    group_by(year, param_group, variable, BHI_ID, HELCOM_ID, Subbasin, country) %>% 
    summarize(count_obs = n()) %>% 
    ungroup()
  
  countdfplot <- ggplot(countdf %>% mutate(BHI_ID = as.factor(BHI_ID))) + 
    geom_point(
        aes(year, BHI_ID, color = count_obs), 
        show.legend = FALSE,
        size = 3, 
        shape = 15, 
        alpha = 0.7
    ) + 
    facet_wrap(~country, nrow = 1, scales = "free_y") +
    labs(x = NULL, y = NULL) +
    scale_color_viridis_c()

  monitordf <- left_join(
    bhi_join_tab,
    countdf %>% 
      mutate(ICES_monitored = TRUE) %>% 
      ## should maybe filter, if fewer than a certain number of measurements in the region?
      # filter(count_obs > 2) %>%
      select(BHI_ID, HELCOM_ID, Subbasin, rgn_nam = country, year, ICES_monitored) %>%
      distinct()
    ) %>% mutate(ICES_monitored = ifelse(is.na(ICES_monitored), FALSE, ICES_monitored))
    
  return(list(monitored = monitordf, obscounts = countdfplot))
}
```

### 3.4.1 Regional monitoring of Concerning Substances {-}

Of the concerning substances which are monitored, some are monitored only in some BHI regions and/or years. The code below is used in assessing this spatial coverage.

```{r creating substances of concern data layer, echo = TRUE}
## read in master table of emerging contaminant
## this was compiled by Andrea and checked by Anna Sobeck for correctness/completeness
data_loc <- file.path(dir_B, "Goals", "CW", "CON")
subst_of_concern <- read_csv(file.path(data_loc, "concerning_substances_lookup.csv"))

## spatial regions table for joining
joindf <- BHI_rgns_shp %>% 
  st_drop_geometry() %>% 
  select(-Area_km2) %>% 
  mutate(
    Subbasin = as.character(Subbasin), 
    HELCOM_ID = as.character(HELCOM_ID),
    rgn_nam = as.character(rgn_nam), 
    rgn_key = as.character(rgn_key)
  ) %>% 
  mutate(year = list(1990:2020)) %>% 
  tidyr::unnest(year)

## loop through substances and determine which regions they are/not monitored in
rgn_monitor_bio_allsubst <- joindf
rgn_monitor_sed_allsubst <- joindf
plotlistbio <- list()
plotlistsed <- list()

for(nm in unique(filter(subst_of_concern, ICES_monitored)$filename)){
  
  bio_fp <- file.path(
    data_loc, 
    "ContaminantsBiota_ConcerningSubstances", 
    sprintf("ContaminantsBiota_%s.csv", nm)
  )
  sed_fp <- file.path(
    data_loc,
    "ContaminantsSediment_ConcerningSubstances", 
    sprintf("ContaminantsSediment_%s.csv", nm)
  )
  
  if(file.exists(bio_fp)){
    regionalmonitoringbio <- get_spatial_monitor_info(
      bio_fp,
      matrix = "bio",
      bhi_join_tab = joindf
    )
    colnames(regionalmonitoringbio$monitored) <- names(regionalmonitoringbio$monitored) %>%
      str_replace("ICES_monitored", paste(nm, "monitored", sep = "_"))

    rgn_monitor_bio_allsubst <- rgn_monitor_bio_allsubst %>%
      left_join(regionalmonitoringbio$monitored)
    
    plotlistbio[[nm]] <- regionalmonitoringbio$obscounts
  }
  if(file.exists(sed_fp)){
    regionalmonitoringsed <- get_spatial_monitor_info(
      sed_fp,
      matrix = "sed",
      bhi_join_tab = joindf
    )
    colnames(regionalmonitoringsed$monitored) <- names(regionalmonitoringsed$monitored) %>% 
      str_replace("ICES_monitored", paste(nm, "monitored", sep = "_"))
    
    rgn_monitor_sed_allsubst <- rgn_monitor_sed_allsubst %>% 
      left_join(regionalmonitoringsed$monitored)
    
    plotlistsed[[nm]] <- regionalmonitoringsed$obscounts
  }
}

## for the remaining substances of concern (not monitored at all) create columns
for(s in unique(filter(subst_of_concern, !ICES_monitored)$filename)){
  ## add to bio dataset
  dfbio <- mutate(rgn_monitor_bio_allsubst, addcolumn = FALSE)
  colnames(dfbio) <- c(names(rgn_monitor_bio_allsubst), paste0(s, "_monitored"))
  rgn_monitor_bio_allsubst <- dfbio
  ## add to sed dataset
  dfsed <- mutate(rgn_monitor_sed_allsubst, addcolumn = FALSE)
  colnames(dfsed) <- c(names(rgn_monitor_sed_allsubst), paste0(s, "_monitored"))
  rgn_monitor_sed_allsubst <- dfsed
}
## join and spread so can easily sum num. substances monitored
rgn_monitor_allsubst <- full_join(
  rgn_monitor_bio_allsubst %>%
    tidyr::pivot_longer(
      cols = ends_with("_monitored"), 
      names_to = "substance", 
      values_to = "bio_monitored"
    ),
  rgn_monitor_sed_allsubst %>%
    tidyr::pivot_longer(
      cols = ends_with("_monitored"), 
      names_to = "substance", 
      values_to = "sed_monitored"
    )
)
rgn_monitor_allsubst <- rgn_monitor_allsubst %>%
  mutate(monitored = bio_monitored|sed_monitored) %>%
  mutate(monitored = ifelse(is.na(monitored), FALSE, monitored)) %>%
  select(-bio_monitored, -sed_monitored) %>% 
  mutate(substance = str_remove(substance, "_monitored"))

# gridExtra::grid.arrange(grobs = plotlistbio, nrow = length(plotlistbio))
# gridExtra::grid.arrange(grobs = plotlistbio, nrow = length(plotlistsed))
```

```{r calculating concerning substances indicator}
## calculating emerging concerning substances indicator
concern_subst_indicator <- rgn_monitor_allsubst %>% 
  mutate(substance = paste0(substance, "_monitored")) %>% 
  tidyr::pivot_wider(names_from = "substance", values_from = "monitored")


num_substances <- length(grep("_monitored", colnames(concern_subst_indicator)))
concern_subst_ind_ts <- data.frame(
  Subbasin = character(), 
  BHI_ID = numeric(),
  proportion_monitored = numeric(),
  dimension = character(),
  year = numeric()
)

for(y in 2018:(min(concern_subst_indicator$year)+4)){
  yrs <- y:(y-4)
  
  concern_subst_ind_ts <- bind_rows(
    concern_subst_ind_ts,
    concern_subst_indicator %>%
      ## look at monitoring only within time period of interest
      filter(year %in% yrs) %>% 
      group_by(rgn_nam, rgn_key, Subbasin, HELCOM_ID, BHI_ID) %>% 
      summarise_at(vars(ends_with("_monitored")), sum) %>% 
      ungroup() %>% 
      mutate_at(vars(ends_with("_monitored")), funs(pmin(1, .))) %>% 
      ## add columns on number substances and number monitored
      mutate(
        num_substances = num_substances,
        num_monitored = rowSums(.[grep("_monitored", names(.))]),
        proportion_monitored = round(num_monitored/num_substances, 2)
      ) %>%
      select(Subbasin, BHI_ID, proportion_monitored) %>% 
      mutate(dimension = "status", year = y)
  )
}

concern_subst_indicator <- filter(concern_subst_ind_ts, year %in% 2014:2018)
```

### 3.4.2 Save concerning substances layer and intermediate datasets {-}

The data layer for the concerning substances indicator contains true/false records per BHI region per year for each of the 35 distinct substances on the [European Chemical Agency Candidate List of substances of very high concern for Authorisation](https://echa.europa.eu/candidate-list-table?p_p_id=disslists_WAR_disslistsportlet&p_p_lifecycle=1&p_p_state=normal&p_p_mode=view&p_p_col_id=column-1&p_p_col_pos=2&p_p_col_count=3&_disslists_WAR_disslistsportlet_javax.portlet.action=searchDissLists).

```{r save oncerning substances layer and intermediate datasets, eval = FALSE}
write_csv(
  rgn_monitor_allsubst %>% 
    select(
      region_id = BHI_ID,
      latitude, longitude, 
      year,
      monitored, 
      substance
    ), 
  file.path(dir_layers, sprintf("cw_con_penalty_bhi%s.csv", assess_year))
)
```

---

## 4. Visualizing Contaminants Data Layers {-}

```{r join cw con indicator layers for plotting}
## join PCB, Dioxin and PFOS indicators, and take average
cw_con <- do.call(rbind, lapply(
  list(
    list(df = pcb_qflag_adjust_indicators$basin_status, dim = "status", ind = "pcb"),
    list(df = pcb_qflag_adjust_indicators$basin_trend, dim = "trend", ind = "pcb"),
    list(df = pfos_qflag_adjust_indicators$basin_status, dim = "status", ind = "pfos"),
    list(df = pfos_qflag_adjust_indicators$basin_trend, dim = "trend", ind = "pfos"),
    list(df = dioxin_qflag_adjust_indicators$basin_status, dim = "status", ind = "dioxin"),
    list(df = dioxin_qflag_adjust_indicators$basin_trend, dim = "trend", ind = "dioxin")
  ), 
  function(x){
    joindf <- x$df %>% 
      ungroup() %>% 
      select(Subbasin, BHI_ID, rgn_nam, !!!syms(x$dim)) %>% 
      mutate(dimension = x$dim, indicator = x$ind)
    colnames(joindf) <- c("Subbasin", "BHI_ID", "rgn_nam", "score", "dimension", "indicator")
    
    return(joindf)
  }
)) 
cw_con_w_penalty <- cw_con %>%   
  dplyr::group_by(BHI_ID, dimension) %>%
  dplyr::mutate(num_indicators = n()) %>%
  ## in first assessment, excluded where only had pcb indicator
  ## have all 3 here though for each case
  # dplyr::filter(num_indicators > 1) %>%
  dplyr::summarise(score = ifelse(
    sum(is.na(score)) == n(), NA,
    mean(score, na.rm = TRUE)
  )) %>%
  dplyr::mutate(score = round(score, 3)) %>%
  ungroup() %>% 
  left_join(concern_subst_indicator, by = c("BHI_ID", "dimension")) %>% 
  mutate(score = ifelse(dimension == "trend", score, score*proportion_monitored))
```

### 4.1 Contaminants data layers Maps & Subbasin Trends {-}

Maps on the left show each indicator's status individually, and the larger map on the right shows the combined status score with PCB, PFOS, and Dioxin indicators averaged and penalized by the Concerning Substances indicator (monitored proportion). 

```{r contaminants maps and trend plots}
mapcols <- c("indianred", "coral", "goldenrod1", "khaki", "lightblue", "steelblue")

mapdf <- bind_rows(
  cw_con %>% 
    select(-rgn_nam) %>% 
    filter(dimension == "status"),
  
  cw_con_w_penalty %>% 
    filter(dimension == "status") %>% 
    tidyr::pivot_longer(
      cols = c("proportion_monitored", "score"),
      names_to = "indicator",
      values_to = "score"
    )
)
mapsf <- left_join(bhi_rgns_simple, mapdf, by = c("Subbasin", "BHI_ID"))

indicatormaps <- basemap + 
  geom_sf(
    data = filter(mapsf, indicator != "score"), aes(fill = score), 
    size = 0.1, alpha = 0.85, show.legend = FALSE
  ) +
  facet_wrap(~ indicator) +
  scale_fill_gradientn(colors = mapcols, limits = c(0, 1), na.value = "gainsboro")

statusmap <- basemap + 
  geom_sf(data = filter(mapsf, indicator == "score"), aes(fill = score), size = 0.1, alpha = 0.85) +
  facet_wrap(~ indicator) +
  scale_fill_gradientn(colors = mapcols, limits = c(0, 1), na.value = "gainsboro") +
  theme(
    legend.background = element_rect(color = "grey"),
    legend.position = c(0.15, 0.75)
  ) +
  labs(fill = "Score")

trendsdf <- left_join(
  cw_con %>% 
    select(-rgn_nam) %>% 
    filter(dimension == "trend") %>% 
    tidyr::pivot_wider(names_from = indicator, values_from = score),
  cw_con_w_penalty %>% 
    filter(dimension == "trend") %>% 
    select(-proportion_monitored, -Subbasin),
  by = c("BHI_ID", "dimension")
)
trendsdf <- trendsdf %>% 
  tidyr::pivot_longer(
    cols = c("pcb", "pfos", "dioxin", "score"), 
    names_to = "indicator",
    values_to = "score"
  ) %>% 
  left_join(
    read_csv(here::here("supplement", "lookup_tabs", "rgns_complete.csv")) %>% 
      select(Subbasin = subbasin, subbasin_order, BHI_ID = region_id, subbasin_order),
    by = c("Subbasin", "BHI_ID")
  ) %>% 
  mutate(
    score_na = ifelse(is.na(score), 1, score),
    indicator = ifelse(indicator == "score", "average_trend", indicator)
  ) %>% 
  arrange(desc(subbasin_order))

trendsdf$Subbasin <- factor(
  trendsdf$Subbasin,
  levels = unique(trendsdf$Subbasin)
)

trendplots <- ggplot(trendsdf, aes(Subbasin, score_na, fill = score)) +
  geom_bar(stat = "identity", position = position_dodge(), show.legend = FALSE) +
  geom_hline(yintercept = 0, color = "grey") +
  scale_fill_gradientn(colors = rev(mapcols), limits = c(-1, 1), na.value = "gainsboro") +
  facet_wrap(~ indicator, nrow = 1) +
  coord_flip() +
  labs(x = NULL, y = NULL) +
  guides() +
  theme_bw()
```

```{r visualize con data layers and trends, results = "show", fig.width = 9.5, fig.height = 7}
laymat <- rbind(
  c(1,1,2,2), c(1,1,2,2),  c(1,1,2,2), c(1,1,2,2),
  c(1,1,2,2), c(1,1,2,2), c(3,3,3,3), c(3,3,3,3), c(3,3,3,3)
)
gridExtra::grid.arrange(
  indicatormaps, statusmap, trendplots, 
  layout_matrix = laymat
)
```

<br>

## 5. Considerations for `BHI3.0` {-}

From the ICES Organofluorines dataset, include PFAS in addition to PFOS. To include PFAS, a suitable reference point will need to be found.

<br>

## 6. References {-}

```{r cw con references, child = refs_path, results = "asis", echo = FALSE}
```

<br>